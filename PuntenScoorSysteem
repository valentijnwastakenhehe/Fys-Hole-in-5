from ast import If
#from syslog import LOG_WARNING
from tracemalloc import start
import odroid_wiringpi as wpi
import time
from multiprocessing import process

LED_PIN1 = 7  # GPIO PIN 7,9
LED_PIN2 = 30  # GPIO PIN 27,30
LDR_PIN1 = 8  # GPIO PIN 1,6,3
LDR_PIN2 = 9  # GPIO PIN 17,20,5
wpi.wiringPiSetup()
# Line 12 t/m 15 bind de variables op Lines 7 t/m 10
wpi.pinMode(LED_PIN1, wpi.OUTPUT)
# aan de WPI waarden van de GPIO pins op de Odroid
wpi.pinMode(LED_PIN2, wpi.OUTPUT)
wpi.pinMode(LDR_PIN1, wpi.INPUT)
wpi.pinMode(LDR_PIN2, wpi.INPUT)
LDR_SCORE1 = 50  # LDR_SCORE1 en 2 zijn de standaard waarde van de score die de speler heeft opgebouwd
LDR_SCORE2 = 20  # Die we later weer kunnen printen op het scherm

while True:
    start_tijd = time.time()  # Bind de variable start_tijd aan de huidige tijd
    secondes = 10  # Hoelang het spel duurt kan aangepast worden

    time.sleep(0.06)  # Hoelang de sensor wacht om weer een waarde te geven
    huidige_tijd = time.time()  # Bind de variable huidige_tijd aan de huidige tijd
    verstreken_tijd = huidige_tijd - start_tijd  # Berekend de verstreken tijd

    # wanneer de sensor het object heeft gezien en daarna de waarde 0 geeft, geef 50 punten.
    if wpi.digitalRead(LDR_PIN1) == 1:
        wpi.digitalWrite(LED_PIN1, wpi.HIGH)
        LDR_SCORE1 = 0
        break
    elif wpi.digitalRead(LDR_PIN1) == 0:
        wpi.digitalWrite(LED_PIN1, wpi.Low)
        LDR_SCORE1 = 0

    while True:
        wpi.digitalRead(LDR_PIN1)
    
        if LDR_PIN1 == 1:
            wpi.digitalRead(LDR_PIN1)
            while wpi.digitalRead(LDR_PIN1) == 1:
                wpi.digitalRead(LDR_PIN1)
                if wpi.digitalRead(LDR_PIN1) == 0:
                    wpi.DigitalRead(LDR_PIN1)
                    LDR_SCORE1 += 50